// routes/uploadRoutes.js
import express from 'express';
import { imageUpload } from '../middleware/uploadMiddleware.js';
import mediaController from '../controllers/mediaController.js';
import { authenticateToken, requireAdmin } from '../middleware/authMiddleware.js';
import { strictLimiter } from '../utils/limiters.js';
import { validateMediaUpload } from '../middleware/validationMiddleware.js';
import csrfProtection from '../utils/csrf.js';
import sharp from 'sharp';
import path from 'path';
import fs from 'fs/promises';
import crypto from 'crypto';
import { sanitizeFilename } from '../utils/utils.js';

/**
 * Routes for media uploads.
 *
 * - `POST /image` accepts multipart/form-data with an `image` field and
 *   stores metadata in the media table. Only authenticated admins may
 *   create media entries.
 */
const uploadRouter = express.Router();

uploadRouter.post('/image', 
  strictLimiter,
  csrfProtection,
  imageUpload.single('image'), 
  validateMediaUpload,
  authenticateToken,
  requireAdmin, 
  async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ 
          success: false, 
          error: 'No file uploaded', 
        });
      }
      const originalName = req.file.originalname;
      const safeOriginal = sanitizeFilename(originalName || 'upload');
      const now = new Date();
      const yyyy = String(now.getFullYear());
      const mm = String(now.getMonth() + 1).padStart(2, '0');

      // Persist under public/assets/media so it is served by express.static
      const publicRoot = path.join(process.cwd(), 'public');
      const mediaDir = path.join(publicRoot, 'assets', 'media', yyyy, mm);
      await fs.mkdir(mediaDir, { recursive: true });

      const baseName = safeOriginal.replace(path.extname(safeOriginal), '') || 'image';
      const unique = crypto.randomBytes(8).toString('hex');
      const outFile = `${Date.now()}-${unique}-${baseName}.webp`;
      const outPath = path.join(mediaDir, outFile);

      // Server-side optimization for LCP: rotate via EXIF, resize, encode to WebP
      const maxWidth = 1600;
      const webpQuality = 80;

      const transformer = sharp(req.file.buffer, { failOn: 'none' })
        .rotate()
        .resize({ width: maxWidth, withoutEnlargement: true })
        .webp({ quality: webpQuality });

      const metadata = await transformer.metadata();
      await transformer.toFile(outPath);

      const publicUrl = `/assets/media/${yyyy}/${mm}/${encodeURIComponent(outFile)}`;

      // Media-Objekt fÃ¼r Datenbank erstellen (postId optional)
      const parsedPostId = req.body && req.body.postId ? Number(req.body.postId) : null;
      const postId = Number.isFinite(parsedPostId) && parsedPostId > 0 ? parsedPostId : null;

      const rawAlt = req.body && typeof req.body.alt_text !== 'undefined' ? String(req.body.alt_text) : '';
      const altText = rawAlt.trim() !== '' ? rawAlt.trim() : undefined;

      const mediaData = {
        postId,
        original_name: originalName,
        file_size: req.file.size,
        mime_type: 'image/webp',
        uploaded_by: req.user.username,
        upload_path: publicUrl,
        ...(altText && { alt_text: altText }),
        // NOTE: width/height not stored in DB schema currently; keep in response only.
        // created_at is auto-generated by DB
      };

      const result = await mediaController.addMedia(mediaData);

      return res.json({
        success: true,
        message: 'Image uploaded successfully',
        location: publicUrl, // TinyMCE expects `location`
        url: publicUrl,
        media: {
          id: result.id,
          originalName,
          upload_path: publicUrl,
          mimeType: 'image/webp',
          width: metadata && metadata.width ? Number(metadata.width) : null,
          height: metadata && metadata.height ? Number(metadata.height) : null,
        },
      });
    } catch (error) {
      console.error('Upload error:', error);
      res.status(500).json({ 
        success: false, 
        error: error.message || 'Upload failed', 
      });
    }
  });

export default uploadRouter;